O JavaRMI possui uma arquitetura que permite computação distribuída usando orientação à objetos. Quando um cliente recebe uma referência para um servidor, o RMI baixa um stub que traduz chamadas daquela referência para chamadas remotas para o servidor. O stub empacota os argumentos do método usando serialização de objeto, e envia a invocação empacotada para o servidor. Do lado do servidor, a chamada recebida pelo sistema RMI está conectada a um skeleton, que é responsável por desempacotar os argumentos e invocar a implementação do servidor do método. Quando a implementação do servidor finaliza sua execução, o skeleton empacota o resultado e o envia para o stub. O stub por sua vez desempacota a resposta e a retorna para o cliente. Tanto o stub quanto o skeleton são gerados a partir da implementação do servidor e o stub usa referências para se comunicar com o skeleton. Essa arquitetura permite que a referência defina como será realizada a comunicação.
Pode-se destacar similaridades entre o texto de Spagnoli e Becker (2003) e o Java RMI pois este é uma forma de reutilização, que fornece uma estrutura para a chamada remota de métodos, por meio de definição das partes que se relacionam e como utilizá-las. Observa-se também que existe uma documentação, dedicada para a arquitetura, padrões de projetos e outros aspectos do Java RMI.
Separam-se, como principais componentes deste tipo de aplicação, o cliente e o servidor, que possuem definições e características próprias, bem como especificações de como devem se comunicar. Para o cliente utilizar o servidor, o servidor deve implementar uma interface Remote, do java rmi, para que seus métodos sejam reconhecidos como remotos e que programas, como o rmic, possam gerar stubs e skeletons para os clientes e servidor, respectivamente.
Nota-se então, que como um modelo de componentes, o Java RMI apresenta os tipos de componentes, servidor e cliente, o cliente utiliza o servidor para invocar métodos remotamente, bem como suas interfaces de implementação, a forma como os diferentes componentes interagem, por meio de skeletons e stubs, e o empacotamento e desempacotamento de dados (marshalling e unmarshalling) que são trocados entre eles. O java RMI fornece implementações e serviços que dão suporte a implementação do modelo descrito, tendo em vista que automatiza a criação de stubs e skeletons, como também facilita a procura do cliente pelo servidor (por meio do Registry, que registra e localiza objetos remotos) e realiza o empacotamento por serialização de dados, facilitando então a implementação deste tipo de software para quem utiliza o Java RMI.

